// Generated by CoffeeScript 1.6.1
(function() {
  var EventEmitter2, PusherChannel, PusherClient, WebSocket, crypto, uuid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    _this = this;

  WebSocket = require('websocket').client;

  uuid = require('node-uuid');

  crypto = require('crypto');

  EventEmitter2 = require('eventemitter2').EventEmitter2;

  PusherChannel = (function(_super) {

    __extends(PusherChannel, _super);

    function PusherChannel(channel_name, channel_data) {
      this.channel_name = channel_name;
      this.channel_data = channel_data;
    }

    return PusherChannel;

  })(EventEmitter2);

  PusherClient = (function(_super) {

    __extends(PusherClient, _super);

    PusherClient.prototype.state = {
      name: 'disconnected',
      socket_id: null
    };

    function PusherClient(credentials) {
      var _this = this;
      this.recieveMessage = function(msg) {
        return PusherClient.prototype.recieveMessage.apply(_this, arguments);
      };
      this.connect = function() {
        return PusherClient.prototype.connect.apply(_this, arguments);
      };
      this.resetActivityCheck = function() {
        return PusherClient.prototype.resetActivityCheck.apply(_this, arguments);
      };
      this.unsubscribe = function(channel_name, channel_data) {
        return PusherClient.prototype.unsubscribe.apply(_this, arguments);
      };
      this.subscribe = function(channel_name, channel_data) {
        return PusherClient.prototype.subscribe.apply(_this, arguments);
      };
      this.credentials = credentials;
    }

    PusherClient.prototype.subscribe = function(channel_name, channel_data) {
      var auth, channel, req, stringToSign;
      stringToSign = "" + this.state.socket_id + ":" + channel_name + ":" + (JSON.stringify(channel_data));
      auth = this.credentials.key + ':' + crypto.createHmac('sha256', this.credentials.secret).update(stringToSign).digest('hex');
      req = {
        id: uuid.v1(),
        event: 'pusher:subscribe',
        data: {
          channel: channel_name,
          auth: auth,
          channel_data: JSON.stringify(channel_data)
        }
      };
      this.connection.sendUTF(JSON.stringify(req));
      channel = this.channels[channel_name];
      if (!channel) {
        channel = new PusherChannel(channel_name, channel_data);
        this.channels[channel_name] = channel;
      }
      return channel;
    };

    PusherClient.prototype.unsubscribe = function(channel_name, channel_data) {
      var auth, channel, req, stringToSign;
      stringToSign = "" + this.state.socket_id + ":" + channel_name + ":" + (JSON.stringify(channel_data));
      auth = this.credentials.key + ':' + crypto.createHmac('sha256', this.credentials.secret).update(stringToSign).digest('hex');
      req = {
        id: uuid.v1(),
        event: 'pusher:unsubscribe',
        data: {
          channel: channel_name,
          auth: auth,
          channel_data: JSON.stringify(channel_data)
        }
      };
      this.connection.sendUTF(JSON.stringify(req));
      channel = this.channels[channel_name];
      if (channel) {
        delete this.channels[channel_name];
        return channel;
      } else {
        return new Error("No subscription to " + channel_name);
      }
    };

    PusherClient.prototype.resetActivityCheck = function() {
      var _this = this;
      if (this.activityTimeout) {
        clearTimeout(this.activityTimeout);
      }
      if (this.waitingTimeout) {
        clearTimeout(this.waitingTimeout);
      }
      return this.activityTimeout = setTimeout(function() {
        _this.connection.sendUTF(JSON.stringify({
          event: "pusher:ping",
          id: uuid.v1(),
          data: {}
        }));
        return _this.waitingTimeout = setTimeout(function() {
          _this.channels.forEach(function(channel) {
            return _this.unsubscribe(channel.channel_name, channel.channel_data);
          });
          if (_this.connection.state !== "open") {
            return _this.connect();
          }
        }, 30000);
      }, 120000);
    };

    PusherClient.prototype.connect = function() {
      var _this = this;
      this.client = new WebSocket();
      this.channels = {};
      this.client.on('connect', function(connection) {
        _this.connection = connection;
        _this.connection.on('message', function(msg) {
          _this.resetActivityCheck();
          return _this.recieveMessage(msg);
        });
        return _this.connection.on('close', function() {
          return _this.connect();
        });
      });
      return this.client.connect("wss://ws.pusherapp.com:443/app/" + this.credentials.key + "?client=node-pusher-server&version=0.0.1&protocol=5&flash=false");
    };

    PusherClient.prototype.recieveMessage = function(msg) {
      var channel, data, payload;
      if (msg.type === 'utf8') {
        payload = JSON.parse(msg.utf8Data);
        if (payload.event === 'pusher:connection_established') {
          data = JSON.parse(payload.data);
          this.state = {
            name: 'connected',
            socket_id: data.socket_id
          };
          this.emit('connect');
        }
        if (payload.event === 'pusher_internal:subscription_succeeded') {
          channel = this.channels[payload.channel];
          if (channel) {
            channel.emit('success');
          }
        }
        channel = this.channels[payload.channel];
        if (channel) {
          return channel.emit(payload.event, JSON.parse(payload));
        }
      }
    };

    return PusherClient;

  })(EventEmitter2);

  module.exports = PusherClient;

}).call(this);
